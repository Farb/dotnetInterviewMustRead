# Database

## ORM的设计思想

![](https://images2018.cnblogs.com/blog/1364581/201804/1364581-20180406215844000-86521220.png)

对于ORM一定是以对象为起点，使用对象构造出LINQ表达式，这样我们在对象的世界中可以描述我们希望对数据库所进行的操作，LINQ的最终实现其实也是Lambda表达式（毕竟LINQ在代码上会直观很多），功能较强的ORM中都会记录对象类型到数据库对象的元数据，使用这些元数据可以将复杂的Lambda表达式翻译成一个通用的中间表达式，这个表达式其实是抽象于各个不同数据库的具体实现，最后中间表达式再按指定数据库的具体实现生成最终的SQL语句，交由ADO.NET对象执行到数据库，如果数据存在返回则会回写到CLR对象中。

## 聚集索引和非聚集索引

   聚集索引： 数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
   聚集索引的好处，索引的叶子节点就是对应的数据节点，可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询。因此在查询方面，聚集索引的速度往往会更占优势。
   注意：SQL Sever默认主键为聚集索引，也可以指定为非聚集索引，而MySQL里主键就是聚集索引。

   非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。
   非聚集索引的二次查询问题：非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。
   要注意的是非聚集索引其实叶子节点除了会存储索引覆盖列的数据，也会存放聚集索引所覆盖的列数据。

   如何解决非聚集索引的二次查询问题？
   建立两列以上的索引（复合索引），即可查询复合索引里的列的数据而不需要进行回表二次查询。建立两列以上的索引，即可查询复合索引里的列的数据而不需要进行回表二次查询。

1. 使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。
2. 非聚集索引在查询的时候可以的话就避免二次查询，这样性能会大幅提升。
3. 不是所有的表都适合建立索引，只有数据量大表才适合建立索引，且建立在选择性高的列上面性能会更好。